#!/usr/bin/env ruby

require 'yaml'
Bundler.require :default

class Object
   def try method, *args
      if self.respond_to? method
         self.send(method, *args)
      else
         nil ; end ; end ; end

settings = YAML.load( IO.read( 'share/cp/hip.yml' ) )
font_settings = YAML.load( IO.read( 'share/fonts/irmucsv.yml' ) )

hips = Hash[ settings[ 'знаци' ].to_a.map do |c|
   hip = c[ 1 ][ 'hip' ]
   if !hip || font_settings[ 'пропускъ' ].include?( hip )
      next ; end
   c[ 1 ][ 'пути' ] = (hip.size - 1).times.to_a.map { |i| hip[0..i] }
   c[ 1 ] && [ hip, c ]
   end.select{ |c| c && c[ 0 ] } ]

# ЧИНИ find dupes in hips

letters = hips.to_a.map {|c| c[ 0 ] }.join('').split(//).uniq.sort

ligatures = hips.to_a.map do |(hip, (_, d))|
   ( d[ 'пути' ].dup << hip ).select { |x| x.size > 1 }
   end.flatten.uniq.sort

puts "Singletons: #{letters.size}"
puts "Ligatures: #{ligatures.size}"

# Generate tex with chars
texheader = <<TEX
\\documentclass[12pt,a6paper,twoside,dvips,civil=antiqua,cs=irmologion]{hipbook}
\\usepackage[utf8]{inputenc}
\\usepackage[T2A]{fontenc}
\\begin{document}

---

TEX

texfooter = <<TEX

\\end{document}
TEX

File.open('hips.tex', 'w') do |f|
   f.puts texheader + hips.keys.join(' ') + texfooter ; end

# append .vpl LIG rules
#
# open .vpl

srcvpl = IO.read 'texmf/fonts/vpl/hiptex/irmucsv.vpl.in'

# grep KRN from LIGTABLE section
#

mode = nil
labels = {}
label = nil
char = nil
chars = {}
i = nil
head = ''
srcvpl.each_line do |l|
   if l =~ /LIGTABLE/
      mode = :ligtable
   elsif l =~ /CHARACTER (.) ([^)]+)/
      chars[ i ] = char if mode == :character
      mode = :character
      char = {}
      i = ($1 == 'C') && $2.ord || $2.to_i(8)
   elsif mode == :ligtable
      if l =~ /LABEL (.) ([^)]+)/
         i = ($1 == 'C') && $2.ord || $2.to_i(8)
         label = ''
      elsif l =~ /STOP/
         label << l
         labels[ i ] = label
      elsif l =~ /KRN/
         label << l ; end 
   elsif mode == :character
      if l =~ /(CHARWD|CHARHT|CHARDP|CHARIC) R ([\d\-\.]+)\)/
         char[ $1 ] = $2 ; end
   else
      head << l ; end ; end

if mode == :character
   chars[ i ] = char ; end

# Update map 256 of UCS8 table
#
#
ucs8map = {}
hips.each do |hip, (_, d)|
   code = d[ 'tex' ]
   if !code && hip.size == 1
      code = hip.ord ; end
   if code
      if ucs8map[ code ]
         $stderr.puts "The place for hip #{hip} is already busy" ; next ; end
      ucs8map[ code ] = hip ; end ; end

# and non-exist char with path to ligatures
hips.each do |hip, (_, d)|
   ( d[ 'пути' ].dup << hip ).each do |path|
      def validate_ucs8_char ucs8map, char
         if ucs8map.key( char )
            return ; end
         free_idx = ( (0..255).to_a - ucs8map.keys ).first
         if !free_idx
            $stderr.puts "There are no free placeholders. Exiting..." ; exit(1) ; end

         ucs8map[ free_idx ]= char ; end

      validate_ucs8_char ucs8map, path[-1]
      validate_ucs8_char ucs8map, path ; end ; end

# Update ligature table
ligs = {}
hips.each do |hip, (_, d)|
   ( d[ 'пути' ].dup << hip )[1..-1].each do |path|
      char = ucs8map.key( path[-1] )
      base = ucs8map.key( path[0..-2] )
      to = ucs8map.key( path )
      if !char
         $stderr.puts "Char '#{path[-1]}' has no placeholder for ligature '#{path}'" ; end
      if !to
         $stderr.puts "Ligature '#{path}' has no placeholder" ; end
      lig = [ char, to ]
      ligs[ base ] ||= []
      if !ligs[ base ].include?( lig )
         ligs[ base ] << lig ; end ; end ; end

#
def charname char
   char && "#{char[ 0 ]}[#{char[ 1 ][ 'hip' ].gsub(/[\(\)<>]/,'_')}]" || "" ; end

File.open( 'texmf/fonts/vpl/hiptex/irmucsv.vpl', 'w' ) do |f|
   f.puts head
   f.puts '(LIGTABLE'
   ligs.keys.sort.each do |lig|
      links = ligs[ lig ]
      hip = hips[ ucs8map[ lig ] ]
      f.puts "   (LABEL O #{lig.to_s(8)}) (comment #{hip && hip[ 0 ]})"
      links.each do |link|
         hipc = link.map {|x| hips[ ucs8map[ x ] ] }
         f.puts "   (LIG O #{link[0].to_s(8)} O #{link[1].to_s(8)})" \
                " (comment + #{charname(hipc[0])} -> #{charname(hipc[1])})" ; end
      f.puts "   (STOP)" ; end
   f.puts '   )'
   ucs8map.keys.sort.each do |code|
      f.puts "(CHARACTER O #{code.to_s(8)}"
#      p code
#      p chars[ code ]
      if !chars[ code ].empty?
         f.puts chars[ code ].to_a.map {|(k,v)| "   (#{k} R #{v})" }.join("\n")
      else
         f.puts '   (CHARWD R 0)' ; end

#      if ucs8map[ code ].size == 1
      char = hips[ ucs8map[ code ] ]
#         p "CODE #{ucs8map[ code ]}, ORD: #{ucs8map[ code ].ord}"
#         ord = char && char[ 1 ][ 'tex' ] || ucs8map[ code ].ord
#         ord = char && char[ 1 ][ 'tex' ] || code
#         if ord > 0xFF
#            $stderr.puts "Char #{ucs8map[ code ]} has no defined tex value" ; end
      if char
         f.puts "   (MAP\n" \
                "      (SETCHAR O #{code.to_s(8)})\n" \
                "      )\n" ; end
         comment = charname(hips[ ucs8map[ code ] ])
         if comment
            f.puts "   (comment #{comment})" ; end
#      p '-'*80
      f.puts '   )' ; end ; end

enc_name = 'ucs8'
File.open( "texmf/dvips/base/#{enc_name}.enc", 'w' ) do |f|
   f.puts "/#{enc_name.upcase}Encoding ["
   (0...32).each do |l|
      (0...8).each do |n|
         idx = l * 8 + n
         adobe_name = hips[ ucs8map[ idx ] ].try(:[], 1 ).try(:[], 'adobe_name') || '.notdef'
         f.print " /#{adobe_name}" ; end
      f.puts "" ; end
   f.puts "] def" ; end

File.open( "texmf/dvips/config/hiptex.map", 'w' ) do |f|
   f.puts "irmucsv Irmologion-Ucs \"#{enc_name.upcase}Encoding\"" ; end
